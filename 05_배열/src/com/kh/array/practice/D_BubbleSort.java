package com.kh.array.practice;

import java.util.Arrays;

public class D_BubbleSort {

	
	/* [정렬 알고리즘]
	 *  <버블 정렬>
	 * 
	 *  1) 정의
	 *  - 두 개의 인접한 원소(레코드)를 검사하여 정렬하는 방법이다.
	 *  - 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 오름차순 정렬 방식
	 *  
	 *  - 레코드가 N개면, N-1번 회전하며 오름 차순으로 정렬된다.
	 *  - 1회전 시, 첫 번째와 두 번째 레코드를 비교하고, 두 번째와 세 번재 레코드를 비교, 세 번째와 네 번째 레코드를 비교...
	 *    마지막-1 번째 레코드와 마지막 레코드를 비교하여 작은 값이 앞으로, 큰 값이 뒤로 위치하게 정렬한다.
	 *  - 정렬된 레코드는 그 다음 정렬에서 제외된다.
	 *  - 2회전 하면 두 번째로 값이 큰 레코드가 끝에서 두번째 자리에 정렬되고, 3회전 부터는 정렬에서 제외된다.
	 *  - 나머지도 같은 방식으로 진행된다.
	 *  - 점차 비교 대상이 줄어드는 방식이다.
	 * 
	 *  -> 시간 복잡도가 상당히 느린 편이지만, 코드가 단순하기 때문에 자주 사용된다.
	 *  -> 그러나 비교할 데이터의 수가 많아질수록 성능이 저하된다.
	 * 
	 *  예시)
	 *  [8, 3, 7, 5, 4, 2]
	 * 1회전 : 3 8 7 5 4 2 
	 *		  3 7 8 5 4 2
	 * 		  3 7 5 8 4 2 
	 * 		  3 7 5 4 8 2
	 *        3 7 5 4 2 8
	 *        
	 * 2회전 : 3 7 5 4 2 8    
	 *        3 5 7 4 2 8
	 *        3 5 4 7 2 8 
	 *        3 5 4 2 7 8 
	 *        
	 * 3회전 : 3 5 4 2 7 8 
	 *        3 4 5 2 7 8 
	 *        3 4 2 5 7 8 
	 *        
	 * 4회전 : 3 4 2 5 7 8 
	 *        3 2 4 5 7 8
	 *        
	 * 5회전 : 2 3 4 5 7 8 
	 *              
	 */
	
	
	/*
	 *  2) 코드
	 */
	
// ====1번====
	public void bubbleSort(int[] arr) {
			int temp = 0;
		for(int i = 0; i < arr.length - 1; i++) {  //outer루프 회전마다 요소 하나의 최종 위치가 확정
			for(int j = 1; j < arr.length - i; j++) {  // 정렬 완료된 원소에 대해서 비교할 필요가 없기 때문에 '범위 - i', 뒤에서부터 집합의 크기를 하나씩 감소하기 때문
				if(arr[j] < arr[j-1]) {      //arr[j] > arr[j+1]
					temp = arr[j-1];		 //temp = array[j];
					arr[j-1] = arr[j];		 //array[j] = array[j+1];
					arr[j] = temp;			 //array[j+1]=temp;
				}
			}
		}
		System.out.println(Arrays.toString(arr));
	}
	
	
//	====2번====
//	public static void bubble_sort(int[] a) {
//		bubble_sort(a, a.length);
//	}
//	
//	private static void bubble_sort(int[]a, int size) {
//		// round는 배열 크기 - 1 만큼 진행된다.
//		for(int i = 1; i < size; i++) {
//			// 각 라운드별 비교횟수는 배열 크기에 현재 라운드를 뺀 만큼 비교한다.
//			for(int j = 0; j < size - i; j++) {
//				/*
//				 * 현재 원소가 다음 원소보다 클 경우
//				 * 서로 원소의 위치를 교환한다.
//				 */
//				if(a[j] > a[j + 1] ){
//					swap(a, j, j +1);
//				}
//				
//				
//			}
//		}
//		
//	}
//	
//	private static void swap(int[]a, int i, int j) {
//		int temp = a[i];
//		a[j] = a[j];
//		a[j] = temp;
//	}
//	
//	====2-1번(수정)====
//	비교 수행할 때 원소가 교환이 안되면, 즉 swap이 발생 안하면 -> 이미 정렬된 데이터라는 뜻이기 때문에 정렬을 종료한다.
//	따라서, 각 라운드에서 비교수행을 했는지를 판단할 수 있는 변수를 하나 두면 된다.
	
//	public static void bubble_sort(int[] a) {
//		bubble_sort(a, a.length);
//	}
//	
//	private static void bubble_sort(int[] a, int size) {
//		
//		//round는 배열 크기 - 1 만큼 진행된다.
//		for(int i = 1; i < size; i++) {
//			
//			boolean swapped = false;
//			
//			//각 라운드별 비교횟수는 배열 크기의 현재 라운드를 뺀 만큼 비교함
//			for(int j = 0; j < size - i; j++) {
//				
//				/*
//				 * 현재 원소가 다음 원소보다 클 경우
//				 * 서로 원소의 위치를 교환하고
//				 * 비교 수행을 했다는 표시로 swapped 변수를 true로 변경한다.
//				 */
//				if(a[j] > a[j + 1]) {
//					swap(a, j, j + 1);
//					swapped = true;
//				}
//				
//			}
//			
//			/*
//			 * 만약 swap된 적이 없다면 이미 정렬되었다는 의미이므로 반복문 종료
//			 */
//			
//			if(swapped == false) {
//				break;
//			}
//		}
//		
//	}
//	
//	private static void swap(int[] a, int i , int j) {
//		int temp = a[i];
//		a[i] = a[j];
//		a[j] = temp;
//		  
//	}
	
	
	
	
	/*
	 *  3) 시간 복잡도(특정 알고리즘이 어떤 문제를 해결하는데 걸리는 시간)
	 *  - 최악 시간 복잡도 : O(n²) 비교, O(n²) 교환
	 *  - 평균 시간 복잡도 : O(n²) 비교, O(n²) 교환
	 *  - 최선 시간 복잡도 : O(n²) 비교, O(1) 교환
	 *  
	 *  - N * (N+1) / 2
	 *  - O(N * N)
	 * 
	 * 삽입 정렬이나 선택 정렬과 같은 시간복잡도를 갖지만, 바로 옆 요소와 자리 교환을 하면서 정렬하기 때문에 거품 정렬의 교환 횟수가 평균적으로 더 많기 때문에
	 * 실질적으로는 삽입, 선택 정렬보다 더 많은 시간이 걸린다. 가장 비효율적인 방법.
	 */
	
	
	/*
	 *  4) 공간 복잡도(작성한 프로그램이 얼마나 많은 공간(메모리)를 차지하느냐를 분석하는 방법)
	 * - 공간 복잡도 : O(1) 보조 
	 */
	
	
	
	
	
	
}
